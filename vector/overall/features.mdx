---
title: Features
---

## Approximate Nearest Neighbor Search


The primary functionality of the vector store is straightforward: identifying the most similar vectors to a given vector. 
While the concept is simple, translating it into a practical product poses significant challenges.

The first naive apporach is to do an exhaustive search. This is each time a vector is asked, 
compare it to every vector stored one by one. This results in very high latencies and not usable. 
To address this issue, Approximate Nearest Neighbor Search(`ANNS`) algorithms come into play. 
These algorithms provide results close to those of an exhaustive search but with a **low-latency**.
In the literature, the comparison of the resuts of `ANNS` with exhaustive search is called the recall rate.
 The higher the recall rate the better.

Several `ANNS` algorithms, such as `HNSW`[1], `NSG`[2], and `DiskANN`[3], are available for selection, 
each with its distinct characteristics. According to `DiskANN` paper, if you try to store your vectors 
in disk and use  `HNSW` or `NSG`, you end up with again very low latencies. `DiskANN` is focused 
on serving queries from disk with **high-latency** and **good recall rate**. 
And this helps Upstash Vector to be **cost-effective**, therefore cheaper compared to alternatives.

Eventhough `DiskANN` has its advantages, it also requires more work to be practical. 
Main problem was that, you can't  insert/update existing index without reindexing all the vectors. 
For this problem, there is another improved  paper `FreshDiskANN`[4]. `FreshDiskANN` improves `DiskANN` via introducing
a temporary index for up-to-date data in memory. Queries are served from both the temporary(up-to-date) index 
and also from the disk. And these temporary indexes are merged to the disk time-to-time behind the scene. 

Upstash Vector is based on `DiskANN` and  `FreshDiskANN` with more improvements based on our 
tests and observations.

### References
1. Malkov, Y. A., Yashunin, D. A. (2016). *Efficient and Robust Approximate Nearest Neighbor Search Using Hierarchical Navigable Small World Graphs*. CoRR, abs/1603.09320 (2016). [http://arxiv.org/abs/1603.09320]
2. Fu, C., Xiang, C., Wang, C., Cai, D. (2019). *Fast Approximate Nearest Neighbor Search with Navigating Spreading-Out Graphs*. Proceedings of the VLDB, 12(5), 461–474. doi: 10.14778/3303753.3303754. [http://www.vldb.org/pvldb/vol12/p461-fu.pdf]
3. Subramanya, S. J., Devvrit, Kadekodi, R., Krishaswamy, R., Simhadri, H. V. (2019). *DiskANN: Fast Accurate Billion-Point Nearest Neighbor Search on a Single Node*. In Proceedings of the 33rd International Conference on Neural Information Processing Systems (NeurIPS '19), Article No.: 1233, Pages 13766–13776. [https://dl.acm.org/doi/abs/10.5555/3454287.3455520]
4. Singh, A., Subramanya, S. J., Krishnaswamy, R., Simhadri, H. V. (2021). *FreshDiskANN: A Fast and Accurate Graph-Based ANN Index for Streaming Similarity Search*. CoRR abs/2105.09613 (2021). [https://arxiv.org/abs/2105.09613]

## Vector Similarity Functions

When creating a vector index in Upstash Vector, you have the flexibility to choose from different vector similarity functions. 
Each function yields distinct query results, catering to specific use cases. Here are the three supported similarity functions:

// TODO sancar usecases are from ChatGPT . Make sure they are correct or remove them.

#### Cosine Similarity

Cosine similarity measures the cosine of the angle between two vectors. It is particularly useful when the magnitude of the vectors is not essential, and the focus is on the orientation. 

**Use Cases:**
- **Natural Language Processing (NLP):** Ideal for comparing document embeddings or word vectors, as it captures semantic similarity irrespective of vector magnitude.
- **Recommendation Systems:** Effective in recommending items based on user preferences or content similarities.

**Score calculation:**

```1 / (1 + squareDistance(v1, v2)```

#### Euclidean Distance

Euclidean distance calculates the straight-line distance between two vectors in a multi-dimensional space. It is well-suited for scenarios where the magnitude of vectors is crucial, providing a measure of their spatial separation.

**Use Cases:**
- **Computer Vision:** Useful in image processing tasks, such as image recognition or object detection, where the spatial arrangement of features is significant.
- **Anomaly Detection:** Valuable for detecting anomalies in datasets, as it considers both the direction and magnitude of differences between vectors.


// TODO sancar: make sure that what `cosine` means here is clear after you understand it
**Score calculation:**
``` 1 + VectorUtil.cosine(v1, v2)) / 2;```

```
  @Override
  public float cosine(byte[] a, byte[] b) {
    // Note: this will not overflow if dim < 2^18, since max(byte * byte) = 2^14.
    int sum = 0;
    int norm1 = 0;
    int norm2 = 0;

    for (int i = 0; i < a.length; i++) {
      byte elem1 = a[i];
      byte elem2 = b[i];
      sum += elem1 * elem2;
      norm1 += elem1 * elem1;
      norm2 += elem2 * elem2;
    }
    return (float) (sum / Math.sqrt((double) norm1 * (double) norm2));
  }
```

#### Dot Product

The dot product measures the similarity by multiplying the corresponding components of two vectors and summing the results. It provides a measure of alignment between vectors.
**Use Cases:**
- **Machine Learning Models:** Commonly used in machine learning for tasks like sentiment analysis or classification, where feature alignment is critical.
- **Collaborative Filtering:** Effective in collaborative filtering scenarios, such as recommending items based on user behavior or preferences.

// TODO sancar: clear this part after understanding the calculation
**Score calculation:**
``` 
// Dot product score computed over signed bytes, scaled to be in [0, 1].
// divide by 2^14 (maximum absolute value of product of 2 signed bytes) * len
    float denom = (float) (a.length * (1 << 14));
(1 + (dotProduct(a, b) / denom)/2;
```

## Metadata

Metadata feature allows you to store context with your vectors to make a connection. 
There can be a couple of uses of this: 
1- You can put the source of the vector in the metadata to use in your application from the query response.
2- You can put some metadata to further filter the results upon the query. We will have more advanced filtering using this 
metadata soon. 

You can set metadata with your vector as follows:

```
curl https://powerful-kodiak-60521-us1-vector.upstash.io/upsert -H "Authorization: Bearer UPSTASH_VECTOR_TOKEN" \
  -d '{
   "id":"4",
   "vector":[0.9215,0.3897,....],
   "metadata":{
      "url":"https://imgur.com/z9AVZLb"
   }
}' 
```

When you do a query or fetch, you can opt-in to retrieve the metadata as follows:

### Query Example

```
curl https://powerful-kodiak-60521-us1-vector.upstash.io/query -H "Authorization: Bearer ABkFMHBvd2VyZnVsLWtvZGlhay02MDUyMS11czFhZG1pbk5ETXdORFkwTm1NdE9HRmtZaTAwWlRVd0xXSmxORFF0TXpnME0yRTJPV0kwWTJReg==" \
  -d '{
   "vector":[0.9215,0.3897,0.2462,0.5659,0.7164,0.5938,0.8842,0.9003,0.7697,0.3231,0.7807,0.9059,0.2992,0.0354,0.4217,0.8668,0.8503,0.7281,0.329,0.5753,0.0873,0.1581,0.0568,0.176,0.5254,0.8638,0.2345,0.6088,0.1713,0.6293,0.933,0.9024,0.012,0.2852,0.4029,0.4121,0.9017,0.8797,0.3394,0.2801,0.0257,0.9619,0.3468,0.2467,0.5775,0.7807,0.7556,0.8833,0.8069,0.0551,0.2992,0.0662,0.6028,0.8364,0.2744,0.377,0.2979,0.764,0.2114,0.9243,0.1715,0.5133,0.9748,0.0047,0.0194,0.772,0.8868,0.344,0.5572,0.2573,0.1207,0.8279,0.7453,0.2043,0.9257,0.7378,0.8725,0.1361,0.9946,0.1781,0.9974,0.8674,0.3012,0.9283,0.1454,0.8146,0.5795,0.076,0.1957,0.803,0.7028,0.819,0.6521,0.345,0.1177,0.0775,0.2989,0.0855,0.2348,0.5109,0.391,0.5028,0.2074,0.4607,0.8954,0.3945,0.377,0.941,0.7287,0.33,0.2719,0.1235,0.7912,0.278,0.2748,0.5292,0.4673,0.9436,0.3234,0.822,0.8098,0.1878,0.8558,0.0697,0.4719,0.1109,0.4711,0.9709,0.6062,0.0185,0.0592,0.0134,0.7283,0.2389,0.1143,0.478,0.8915,0.0185,0.5557,0.1555,0.6548,0.9855,0.6851,0.0271,0.2787,0.2949,0.2159,0.7251,0.3795,0.4786,0.3324,0.8413,0.1192,0.0111,0.7911,0.037,0.9428,0.5047,0.9728,0.6609,0.9299,0.6419,0.5839,0.7869,0.6756,0.7894,0.5465,0.7338,0.3399,0.6466,0.4491,0.8217,0.0154,0.5368,0.9514,0.1672,0.4414,0.7443,0.0915,0.8068,0.249,0.1744,0.0917,0.1744,0.585,0.8622,0.2752,0.8769,0.3271,0.0015,0.4906,0.2287,0.6783,0.0727,0.1383,0.7406,0.506,0.4616,0.6654,0.0424,0.5458,0.3775,0.6644,0.2096,0.7953,0.9291,0.17,0.0243,0.4457,0.1459,0.7726,0.8755,0.7775,0.9916,0.5813,0.0977,0.2199,0.7747,0.5939,0.5836,0.9961,0.5707,0.1376,0.3597,0.109,0.3498,0.6078,0.8413,0.4704,0.0593,0.1028,0.4695,0.6404,0.4603,0.8835,0.6264,0.4465,0.9985,0.7223,0.1565,0.7387,0.4494,0.9828,0.0089,0.2259,0.3903,0.6179,0.2722,0.9372,0.8001,0.9829,0.0736,0.1117,0.1846,0.5941,0.5594],
   "topK" : 5,
   "includeMetadata": true
}' 
// Response
{
  "result": [
    {
      "id": "1", "score": 1,
      "metadata": {
        "url": "https://imgur.com/z9AVZLb"
      }
    },
    {
      "id": "3", "score": 0.99961007,
      "metadata": {
        "url": "https://imgur.com/zfOPmnI"
      }
    }
  ]
}
```

## Range Example:

```
curl https://powerful-kodiak-60521-us1-vector.upstash.io/range -H "Authorization: Bearer ABkFMHBvd2VyZnVsLWtvZGlhay02MDUyMS11czFhZG1pbk5ETXdORFkwTm1NdE9HRmtZaTAwWlRVd0xXSmxORFF0TXpnME0yRTJPV0kwWTJReg==" \
  -d '{ "cursor" : "",  "limit" : 3, "includeMetadata": true}' 
// Response
{
  "result": {
    "nextCursor": "4",
    "vectors": [
      {"id": "1", "metadata": {"url": "https://imgur.com/z9AVZLb"}},
      {"id": "2", "metadata": {"url": "https://imgur.com/a2nCEIt"}},
      {"id": "3", "metadata": {"url": "https://imgur.com/zfOPmnI"}}
    ]
  }
}
```