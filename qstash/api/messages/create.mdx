---
title: "Publish a Message"
description: "Publish a new message to QStash"
api: "POST /v2/publish/{destination}"
authMethod: "bearer"
---

## Request

<ParamField path="destination" type="string" required>
Destination can either be a topic name or id that you configured in the Upstash console,
or a valid url where the message gets sent to.
Make sure the url is prefixed with a valid protocol (`http://` or `https://`)
</ParamField>


<ParamField body="body" type="string" >
The raw request message passed to the endpoints as is
</ParamField>


<ParamField header="ContentType" type="string" >
ContentType is the MIME type of the message.

 We highly recommend sending a `Content-Type` header along, as this will help your destination
 API to understand the content of the message.

 For example `application/json`, `application/xml`, `application/octet-stream`, `text/plain`
 </ParamField>


 <ParamField header="Upstash-Deduplication-Id" type="string" >
  Provide a unique id for deduplication.

  This id will be used to detect duplicate messages.
  If a duplicate message is detected, the request will be accepted but not enqueued.
  Deduplication ids must not contain `:` or whitespace.

  We store deduplication ids for 90 days. Afterwards it is possible that the message with the same deduplication id is delivered again.

  When scheduling a message, the deduplication happens before the schedule is created.
</ParamField>

<ParamField header="Upstash-Content-Based-Deduplication" type="boolean" >
If true, the message content will get hashed and used as deduplication id.
If a duplicate message is detected, the request will be accepted but not enqueued.
The content based hash includes the following values:
- All headers prefixed with `Upstash` this includes all custom headers you are sending.
- The entire raw request body
- The destination from the url path
We store deduplication ids for 90 days. Afterwards it is possible that the message with thee deduplication id is delivered again.
When scheduling a message, the deduplication happens before the schedule is created.
Messages created by schedules are not deduplicated.

</ParamField>
<ParamField header="Upstash-Method" type="string" default="POST" >
	The HTTP method to use when sending a webhook to your API.


</ParamField>

<ParamField header="Upstash-Not-Before" type="int" >
 Delay the first delivery attempt until this time
 Unix timestamp with second precision.
 This overrides `Upstash-Delay` if both are provided.
 example: 1657093973
</ParamField>

<ParamField header="Upstash-Delay" type="string" >

 Delay the first delivery attempt.

 Format for this header is a number followed by duration abbreviation, like `10s`.
 Available durations are `s` (seconds), `m` (minutes), `h` (hours), `d` (days).

 Overridden by `Upstash-Not-Before` if both are provided.

 example: "50s" | "3m" | "10h" | "1d"

</ParamField>

<ParamField header="Upstash-Retries" type="int" default={3} >
 How often should this messasge be retried in case the destination API is not available.

 The total number of deliveries is therefore capped at `1 + retries`

 Leave this empty to use the default value, (free tier: 3, paid tier: 5)

 The backoff duration in seconds is calculated as follows:
 `n` is the number of times the task has been retried.

 `min(86400, e ** (2 * n))`


</ParamField>
<ParamField header="Upstash-Callback" type="string" >
You can define a callback url that will be called with the response from the destination API.
Callbacks are experimental, and the API might change in the future!
- The callback url must be prefixed with a valid protocol (`http://` or `https://`)
- Callbacks are charged as a regular message.
- Callbacks will use the retry setting from the original request.
</ParamField>

<ParamField header="Upstash-Forward-*" type="string" >
 You can send custom headers along with your message.

 To send a custom header, prefix the header name with `Upstash-Forward-`. We will strip efix and them to the destination API.

 example: "Upstash-Forward-My-Header: my-value" -> "My-Header: my-value"
</ParamField>

{/* 
Not yet implemented :)
<ParamField header="Upstash-Partition-Key" type="string" >
PartitionKey allows you to group messages together and guarantee ordering within a partition.
</ParamField> */}

## Response

<ResponseField name="id" type="string" required>
  The endpoint ID.
</ResponseField>
<ResponseField name="method" type="string" required>
The HTTP method to use when making requests to this endpoint.
</ResponseField>
<ResponseField name="name" type="string" required>
The name of the endpoint.
</ResponseField>
<ResponseField name="teamId" type="string" required>
The ID of the team that owns this endpoint.
</ResponseField>
<ResponseField name="url" type="string" required>
The URL of the endpoint.
</ResponseField>
<ResponseField name="createdAt" type="string" required>
When this endpoint was created.
</ResponseField>


<ResponseField name="updatedAt" type="string" required>
When this endpoint was last updated.
</ResponseField>
<ResponseField name="followRedirects" type="boolean" required>
Whether or not to follow redirects when making requests to this endpoint.
If `false`, redirects will be returned as responses.
</ResponseField>
<ResponseField name="prewarm" type="boolean" required>
Whether or not to prewarm this endpoint.
When `true`, the endpoint will be called twice and only the second response will be measured.
</ResponseField>
<ResponseField name="runs" type="number" required>
The number of runs to make when measuring this endpoint.
</ResponseField>
<ResponseField name="interval" type="number" required>
The interval between checks. In milliseconds.
</ResponseField>
<ResponseField name="active" type="boolean" required>
Whether or not this endpoint is active.
</ResponseField>
<ResponseField name="degradedAfter" type="number">
After this time in milliseconds, the endpoint will be considered degraded.
</ResponseField>
<ResponseField name="timeout" type="number" required>
The timeout for requests to this endpoint. In milliseconds.
</ResponseField>
<ResponseField name="distribution" type="ALL | RANDOM" required>
The distribution of runs across regions. `ALL` will run in all regions at the same time. `RANDOM` will run in a random region.
</ResponseField>

<ResponseField name="regions" type="Array" required>
  <Expandable title="properties">

  <ResponseField name="id" type="string" required>
    The ID of the region.
  </ResponseField>
</Expandable>
</ResponseField>


<ResponseField name="headers" type="Record<string, string>" >
  The headers to send with requests to this endpoint.
</ResponseField>

<ResponseField name="body" type="string" >
  The body to send with requests to this endpoint.
</ResponseField>

<ResponseField name="assertions" type="Array" >
  Assertions to run against responses from this endpoint.
</ResponseField>


<RequestExample>



```sh publish to url
curl -XPOST https://qstash.upstash.io/v2/publish/https://example.com \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"hello": "world"}'
```

```sh publish to topic
curl -XPOST https://qstash.upstash.io/v2/publish/my-topic \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"hello": "world"}'
```




</RequestExample>

<ResponseExample>
```json publish to url
{
  "messageId": "msg_1234"
}
```


```json publish to topic
{
  "messageIds": ["msg_1234","msg_5678"]
}
```
</ResponseExample>
